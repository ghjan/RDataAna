#聚类和分类的区别
#根据几何特征
#距离
#密度

#距离
#薛毅P469
#绝对值距离
#也称为棋盘距离或城市街区距离

x1=c(1,2,3,4,5)
x2=c(3,2,1,4,6)
x3=c(5,3,5,6,2)
x=data.frame(x1,x2,x3)
##生成距离对象或者距离矩阵
dist(x,method='euclidean')
         1        2        3        4
2 2.449490                           
3 2.828427 2.449490                  
4 3.316625 4.123106 3.316625         
5 5.830952 5.099020 6.164414 4.582576
x
  x1 x2 x3
1  1  3  5
2  2  2  3
3  3  1  5
4  4  4  6
5  5  6  2
dist(x,method='maximum')
  1 2 3 4
2 2      
3 2 2    
4 3 3 3  
5 4 4 5 4
dist(x,method='manhattan')
   1  2  3  4
2  4         
3  4  4      
4  5  7  5   
5 10  8 10  7
dist(x,method='canberra')
          1         2         3         4
2 0.7833333                              
3 1.0000000 0.7833333                    
4 0.8337662 1.0000000 0.8337662          
5 1.4285714 1.1285714 1.3928571 0.8111111

dist(x,method='minkowski')  #p=2,就是欧氏距离
         1        2        3        4
2 2.449490                           
3 2.828427 2.449490                  
4 3.316625 4.123106 3.316625         
5 5.830952 5.099020 6.164414 4.582576
dist(x,method='minkowski',p=5) # 默认为2
         1        2        3        4
2 2.024397                           
3 2.297397 2.024397                  
4 3.004922 3.143603 3.004922         
5 4.323101 4.174686 5.085057 4.025455

dist(x)  #默认method是euclidean
         1        2        3        4
2 2.449490                           
3 2.828427 2.449490                  
4 3.316625 4.123106 3.316625         
5 5.830952 5.099020 6.164414 4.582576

dist(x,method='binary')
  1 2 3 4
2 0      
3 0 0    
4 0 0 0  
5 0 0 0 0

y1=c("F","F","M", "F", "M")
y2=c("A","B","B","C","A")
y3=c(2,3,1,2,3)
y=data.frame(y1,y2,y3)
dist(y,method = 'binary')
  1 2 3 4
2 0      
3 0 0    
4 0 0 0  
5 0 0 0 0
Warning message:
In dist(y, method = "binary") : NAs introduced by coercion

y1=c(1,0,1,1,0,0,1)
y2=c(1,0,0,0,1,1,1)
y3=c(1,1,1,0,0,1,1)
y = data.frame(y1,y2,y3)
y
  y1 y2 y3
1  1  1  1
2  0  0  1
3  1  0  1
4  1  0  0
5  0  1  0
6  0  1  1
7  1  1  1
dist(y,method='binary')
          1         2         3         4         5         6
2 0.6666667                                                  
3 0.3333333 0.5000000                                        
4 0.6666667 1.0000000 0.5000000                              
5 0.6666667 1.0000000 1.0000000 1.0000000                    
6 0.3333333 0.5000000 0.6666667 1.0000000 0.5000000          
7 0.0000000 0.6666667 0.3333333 0.6666667 0.6666667 0.3333333

#数据中心化与标准化变换
##中心化：以0位平均值
##标准化：大小规模差不多，看做正态分布，每个数值除以标准差或者极差
##目的：使得各个变量平等发挥作用
##scale()函数 中心化和标准化
x
  x1 x2 x3
1  1  3  5
2  2  2  3
3  3  1  5
4  4  4  6
5  5  6  2
scale(x,center = T, scale=T)
             x1         x2         x3
[1,] -1.2649111 -0.1039750  0.4868645
[2,] -0.6324555 -0.6238503 -0.7302967
[3,]  0.0000000 -1.1437255  0.4868645
[4,]  0.6324555  0.4159002  1.0954451
[5,]  1.2649111  1.4556507 -1.3388774
attr(,"scaled:center")
 x1  x2  x3 
3.0 3.2 4.2 
attr(,"scaled:scale")
      x1       x2       x3 
1.581139 1.923538 1.643168 

##极差化 sweep()函数 
## 薛毅473
sweep(x, 2, apply(x, 2, mean))
  x1   x2   x3
1 -2 -0.2  0.8
2 -1 -1.2 -1.2
3  0 -2.2  0.8
4  1  0.8  1.8
5  2  2.8 -2.2

#类与类之间的距离
#P476
#作业：递推公式的推导

#exam0806.R
x<-c(1,2,6,8,11); dim(x)<-c(5,1)
d<-dist(x)
hc1<-hclust(d, "single"); 
hc2<-hclust(d, "complete")#最长
hc3<-hclust(d, "median"); #中间距离法
hc4<-hclust(d, "mcquitty") #mcquitty相似法
# average - 类平均法
# centroid - 重心法
# ward - 离差平方和法

#画出谱系图
opar <- par(mfrow = c(2, 2))
# plot(x, labels = NULL, hang = 0.1,
#   axes = TRUE, frame.plot = FALSE, ann = TRUE,
#   main = "Cluster Dendrogram",
#   sub = NULL, xlab = NULL, ylab = "Height", ...)
plot(hc1,hang=-1); plot(hc2,hang=-1) # hang<0 谱系图的类从底部画起
plot(hc3,hang=-1); plot(hc4,hang=-1)
par(opar)

#画出各种谱系图 三角的 虚线的 横放的
#dendrogram n.  系统树图（一种表示亲缘关系的树状图解）
# 与谱系图有关的函数还有as.dendrogram(),将系统聚类得到的对象强制为谱系图
# 使用格式是 as.dendrogram(object, hang=-1,...)
# plot()函数的用法是:
# plot(x, type = c("rectangle", "triangle"),
  # center = FALSE,
  # edge.root = is.leaf(x) || !is.null(attr(x,"edgetext")),
  # nodePar = NULL, edgePar = list(),
  # leaflab = c("perpendicular", "textlike", "none"),
  # dLeaf = NULL, xlab = "", ylab = "", xaxt = "n", yaxt = "s",
  # horiz = FALSE, frame.plot = FALSE, ...)
  # 其中x是由dendrogram得到的对象，type表示画谱系图的类型，
dend1<-as.dendrogram(hc1)
opar <- par(mfrow = c(2, 2),mar = c(4,3,1,2))
plot(dend1)
plot(dend1, nodePar=list(pch = c(1,NA), cex=0.8, lab.cex = 0.8),
     type = "t", center=TRUE)
plot(dend1, edgePar=list(col = 1:2, lty = 2:3), dLeaf=1, edge.root = TRUE)
plot(dend1, nodePar=list(pch = 2:1,cex=.4*2:1, col = 2:3), horiz=TRUE)#谱系图水平放置
par(opar)


#变量的分类
#相似系数-相关系数
#Exam0807.R
## 输入相关矩阵. 
x<- c(1.000, 0.846, 0.805, 0.859, 0.473, 0.398, 0.301, 0.382,
      0.846, 1.000, 0.881, 0.826, 0.376, 0.326, 0.277, 0.277, 
      0.805, 0.881, 1.000, 0.801, 0.380, 0.319, 0.237, 0.345, 
      0.859, 0.826, 0.801, 1.000, 0.436, 0.329, 0.327, 0.365, 
      0.473, 0.376, 0.380, 0.436, 1.000, 0.762, 0.730, 0.629, 
      0.398, 0.326, 0.319, 0.329, 0.762, 1.000, 0.583, 0.577, 
      0.301, 0.277, 0.237, 0.327, 0.730, 0.583, 1.000, 0.539, 
      0.382, 0.415, 0.345, 0.365, 0.629, 0.577, 0.539, 1.000)
names<-c("身高 x1", "手臂长 x2", "上肢长 x3", "下肢长 x4", "体重 x5", 
         "颈围 x6", "胸围 x7", "胸宽 x8")
r<-matrix(x, nrow=8, dimnames=list(names, names))
## 作系统聚类分析, 
## as.dist()的作用是将普通矩阵转化为聚类分析用的距离结构. 
d<-as.dist(1-r); hc<-hclust(d); dend<-as.dendrogram(hc)
## 写一段小程序, 其目的是在绘图命令中调用它, 使谱系图更好看.
nP<-list(col=3:2, cex=c(2.0, 0.75), pch= 21:22, 
         bg= c("light blue", "pink"),
         lab.cex = 1.0, lab.col = "tomato")
addE <- function(n){
  if(!is.leaf(n)) {
    attr(n, "edgePar") <- list(p.col="plum")
    attr(n, "edgetext") <- paste(attr(n,"members"),"members")
  }
  n
}
## 画出谱系图.
op<-par(mfrow=c(1,1), mar=c(4,3,0.5,0))
de <- dendrapply(dend, addE); plot(de, nodePar= nP)
par(op)


#R12.pdf封面就是一个生物的谱系图
##亲缘关系
##细胞 DNA特征

#类个数的确定
##分成多少类？
##三种基本的方法
##四个准则
##
##函数rect.hclust()就是用来做类的个数
#rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL,
# border = 2, cluster = NULL)
#tree：hclust生成的结构, h:阈值，k:类的个数
plclust(hc, hang=-1) #deprecated
re<-rect.hclust(hc, k=3)#分为三类变量

##plclust是过时了，使用plot代替
plot(hc, hang=-1);
re<-rect.hclust(hc, k=3)#分为三类变量

#综合实例
#exam0808.R
#1999年，31个省市，
#消费性支出数据：食品，穿衣服，家庭用品，医疗，交通通讯，娱乐教育文化服务，居住，杂项商品和服务
X<-data.frame(
  x1=c(2959.19, 2459.77, 1495.63, 1046.33, 1303.97, 1730.84, 
       1561.86, 1410.11, 3712.31, 2207.58, 2629.16, 1844.78, 
       2709.46, 1563.78, 1675.75, 1427.65, 1783.43, 1942.23, 
       3055.17, 2033.87, 2057.86, 2303.29, 1974.28, 1673.82, 
       2194.25, 2646.61, 1472.95, 1525.57, 1654.69, 1375.46, 
       1608.82), 
  x2=c(730.79, 495.47, 515.90, 477.77, 524.29, 553.90, 492.42, 
       510.71, 550.74, 449.37, 557.32, 430.29, 428.11, 303.65, 
       613.32, 431.79, 511.88, 512.27, 353.23, 300.82, 186.44, 
       589.99, 507.76, 437.75, 537.01, 839.70, 390.89, 472.98, 
       437.77, 480.99, 536.05),
  x3=c(749.41, 697.33, 362.37, 290.15, 254.83, 246.91, 200.49, 
       211.88, 893.37, 572.40, 689.73, 271.28, 334.12, 233.81, 
       550.71, 288.55, 282.84, 401.39, 564.56, 338.65, 202.72, 
       516.21, 344.79, 461.61, 369.07, 204.44, 447.95, 328.90, 
       258.78, 273.84, 432.46), 
  x4=c(513.34, 302.87, 285.32, 208.57, 192.17, 279.81, 218.36, 
       277.11, 346.93, 211.92, 435.69, 126.33, 160.77, 107.90, 
       219.79, 208.14, 201.01, 206.06, 356.27, 157.78, 171.79, 
       236.55, 203.21, 153.32, 249.54, 209.11, 259.51, 219.86, 
       303.00, 317.32, 235.82),
  x5=c(467.87, 284.19, 272.95, 201.50, 249.81, 239.18, 220.69, 
       224.65, 527.00, 302.09, 514.66, 250.56, 405.14, 209.70, 
       272.59, 217.00, 237.60, 321.29, 811.88, 329.06, 329.65, 
       403.92, 240.24, 254.66, 290.84, 379.30, 230.61, 206.65, 
       244.93, 251.08, 250.28),
  x6=c(1141.82, 735.97, 540.58, 414.72, 463.09, 445.20, 459.62, 
       376.82, 1034.98, 585.23, 795.87, 513.18, 461.67, 393.99, 
       599.43, 337.76, 617.74, 697.22, 873.06, 621.74, 477.17, 
       730.05, 575.10, 445.59, 561.91, 371.04, 490.90, 449.69, 
       479.53, 424.75, 541.30),
  x7=c(478.42, 570.84, 364.91, 281.84, 287.87, 330.24, 360.48, 
       317.61, 720.33, 429.77, 575.76, 314.00, 535.13, 509.39, 
       371.62, 421.31, 523.52, 492.60, 1082.82, 587.02, 312.93, 
       438.41, 430.36, 346.11, 407.70, 269.59, 469.10, 249.66, 
       288.56, 228.73, 344.85),
  x8=c(457.64, 305.08, 188.63, 212.10, 192.96, 163.86, 147.76, 
       152.85, 462.03, 252.54, 323.36, 151.39, 232.29, 160.12, 
       211.84, 165.32, 182.52, 226.45, 420.81, 218.27, 279.19, 
       225.80, 223.46, 191.48, 330.95, 389.33, 191.34, 228.19, 
       236.51, 195.93, 214.40),
  row.names = c("北京", "天津", "河北", "山西", "内蒙古", "辽宁", "吉林", 
                "黑龙江", "上海", "江苏", "浙江", "安徽", "福建", "江西", 
                "山东",  "河南", "湖北", "湖南", "广东", "广西", "海南", 
                "重庆", "四川", "贵州", "云南", "西藏", "陕西", "甘肃", 
                "青海", "宁夏", "新疆")
)
Province<-dist(scale(X))
##四种聚类算法
hc1<-hclust(Province, "complete")
hc2<-hclust(Province, "average")
hc3<-hclust(Province, "centroid")
hc4<-hclust(Province, "ward")

opar<-par(mfrow=c(2,1), mar=c(5.2,4,0,0))
plclust(hc1,hang=-1)
re1<-rect.hclust(hc1,k=5,border="red")
plclust(hc2,hang=-1)
re2<-rect.hclust(hc2,k=5,border="red")
par(opar)

opar<-par(mfrow=c(2,1), mar=c(5.2,4,0,0))
plclust(hc3,hang=-1)
re3<-rect.hclust(hc3,k=5,border="red")
plclust(hc4,hang=-1)
re4<-rect.hclust(hc4,k=5,border="red")
par(opar)
X<-data.frame(
  x1=c(2959.19, 2459.77, 1495.63, 1046.33, 1303.97, 1730.84, 
       1561.86, 1410.11, 3712.31, 2207.58, 2629.16, 1844.78, 
       2709.46, 1563.78, 1675.75, 1427.65, 1783.43, 1942.23, 
       3055.17, 2033.87, 2057.86, 2303.29, 1974.28, 1673.82, 
       2194.25, 2646.61, 1472.95, 1525.57, 1654.69, 1375.46, 
       1608.82), 
  x2=c(730.79, 495.47, 515.90, 477.77, 524.29, 553.90, 492.42, 
       510.71, 550.74, 449.37, 557.32, 430.29, 428.11, 303.65, 
       613.32, 431.79, 511.88, 512.27, 353.23, 300.82, 186.44, 
       589.99, 507.76, 437.75, 537.01, 839.70, 390.89, 472.98, 
       437.77, 480.99, 536.05),
  x3=c(749.41, 697.33, 362.37, 290.15, 254.83, 246.91, 200.49, 
       211.88, 893.37, 572.40, 689.73, 271.28, 334.12, 233.81, 
       550.71, 288.55, 282.84, 401.39, 564.56, 338.65, 202.72, 
       516.21, 344.79, 461.61, 369.07, 204.44, 447.95, 328.90, 
       258.78, 273.84, 432.46), 
  x4=c(513.34, 302.87, 285.32, 208.57, 192.17, 279.81, 218.36, 
       277.11, 346.93, 211.92, 435.69, 126.33, 160.77, 107.90, 
       219.79, 208.14, 201.01, 206.06, 356.27, 157.78, 171.79, 
       236.55, 203.21, 153.32, 249.54, 209.11, 259.51, 219.86, 
       303.00, 317.32, 235.82),
  x5=c(467.87, 284.19, 272.95, 201.50, 249.81, 239.18, 220.69, 
       224.65, 527.00, 302.09, 514.66, 250.56, 405.14, 209.70, 
       272.59, 217.00, 237.60, 321.29, 811.88, 329.06, 329.65, 
       403.92, 240.24, 254.66, 290.84, 379.30, 230.61, 206.65, 
       244.93, 251.08, 250.28),
  x6=c(1141.82, 735.97, 540.58, 414.72, 463.09, 445.20, 459.62, 
       376.82, 1034.98, 585.23, 795.87, 513.18, 461.67, 393.99, 
       599.43, 337.76, 617.74, 697.22, 873.06, 621.74, 477.17, 
       730.05, 575.10, 445.59, 561.91, 371.04, 490.90, 449.69, 
       479.53, 424.75, 541.30),
  x7=c(478.42, 570.84, 364.91, 281.84, 287.87, 330.24, 360.48, 
       317.61, 720.33, 429.77, 575.76, 314.00, 535.13, 509.39, 
       371.62, 421.31, 523.52, 492.60, 1082.82, 587.02, 312.93, 
       438.41, 430.36, 346.11, 407.70, 269.59, 469.10, 249.66, 
       288.56, 228.73, 344.85),
  x8=c(457.64, 305.08, 188.63, 212.10, 192.96, 163.86, 147.76, 
       152.85, 462.03, 252.54, 323.36, 151.39, 232.29, 160.12, 
       211.84, 165.32, 182.52, 226.45, 420.81, 218.27, 279.19, 
       225.80, 223.46, 191.48, 330.95, 389.33, 191.34, 228.19, 
       236.51, 195.93, 214.40),
  row.names = c("北京", "天津", "河北", "山西", "内蒙古", "辽宁", "吉林", 
                "黑龙江", "上海", "江苏", "浙江", "安徽", "福建", "江西", 
                "山东",  "河南", "湖北", "湖南", "广东", "广西", "海南", 
                "重庆", "四川", "贵州", "云南", "西藏", "陕西", "甘肃", 
                "青海", "宁夏", "新疆")
)
Province<-dist(scale(X))
hc1<-hclust(Province, "complete")
hc2<-hclust(Province, "average")
hc3<-hclust(Province, "centroid")
hc4<-hclust(Province, "ward")

opar<-par(mfrow=c(2,1), mar=c(5.2,4,0,0))
##最长距离
plclust(hc1,hang=-1)
re1<-rect.hclust(hc1,k=5,border="red")
##类平均
plclust(hc2,hang=-1)
re2<-rect.hclust(hc2,k=5,border="red")
par(opar)

opar<-par(mfrow=c(2,1), mar=c(5.2,4,0,0))
##重心法
plclust(hc3,hang=-1)
re3<-rect.hclust(hc3,k=5,border="red")
##离差平方和法 结果最好
plclust(hc4,hang=-1)
re4<-rect.hclust(hc4,k=5,border="red")
par(opar)

